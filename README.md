# SNHU.CS330.ComputerGraphics
This repository is for work completed in SNHU CS 330 Computer Graphics and Visualization. Download and run the executable in the source to see my design.

## For my scene I chose to model items that were within arm’s reach while at my desk. I elected to try and model a Rubik’s Cube, an electronics breadboard, and a glue stick. At the outset I suspected I would be able to make basic shapes to represent these items and overlay them with actual images, resulting in a somewhat realistic model. I would say that, except for minor errors in applying the images as textures, I am happy with the resulting product. Some of the inconsistencies with the application of the images are purposeful, for example I chose to use the same breadboard image on the sides as I applied for the top. The top of the breadboard was the most important to make the item somewhat realistic so I used the same image for the sides because I thought at least having the correct colors would be passable. The final iteration of the breadboard has some discernable lines from the original image but at least has the same general colors. The glue stick image was mapped twice across the cylinder body, and I elected to apply the image once again on the lid so that, again, the same colors are applied. For the Rubik’s Cube model, a plain png file was used. The black area around the shape was not discernable until it was applied to the object. After running the program and inspecting the result, I decided that the black area around the image was a decent approximation of the original item because of the original also containing black elements on the edges of the colored squares, although much smaller. 
##	To create the basic shapes, I drew out the shapes I wanted to use and then wrote out the coordinates for the point and texture for each panel of the object. This information was organized into a vector. After this, I drew with the existing points by passing them as indices to be drawn for each triangle. 
##	To navigate the scene, the user must first press the left alt key. After applying the left alt key and continuing to hold it down, the user will be able to rotate the view around the center point of the scene by moving the mouse horizontally while adjusting the view angle to a limited degree by moving the mouse vertically up or down. Zooming in an out is accomplished by continuing to hold down the left alt key and using the scroll wheel of the mouse. Escaping will close the scene. 
##	The functions used in my program are generally concerned with passing information about the objects to be drawn to the GPU. Each element is composed of, at it’s purest state, the data structure holding the information about the object. This is passed to the virtual array object via vertex attribute pointers that correspond to the information layout in the vector. This array object is used to make modifications to the model matrix and draw the object. The objects get their color or texture information from vertex and fragment shaders which are bound before binding the vertex array objects.  The draw functions are custom functions that pass the GLenum mode and GLsizei indices to the actual command to draw elements (glDrawElements()). Another custom function in the program is CompileShader(). This takes a constant string reference along with an unsigned integer that represents the shader type. CompileShader is static and returns an unsigned integer, in this case the type is GLuint.  The glCreateShader() function is called with shaderType as the argument and assigned to an unsigned integer named shaderID. A constant character pointer named src is assigned the value of the source reference to a c string with source.c_str(). From here, glShaderSource() is called with arguments of shaderID, 1, a reference to src, and a null pointer. Next, glCompileShader() is called with shaderID as the argument and, finally, shaderID is returned by the CompileShader function. 
